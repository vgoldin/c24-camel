## Camel C24 IO Support

The Camel [C24IO Data Format][DataFormat] supports the [C24 IO][C24] product which provides a framework for reading and writing a huge number of vertical message payloads like SWIFT, SEPA, FpML, TWIST, ISO 20022, CREST and FIX.

In addition C24IO provides tooling and a framework for reading and writing any legacy binary or text file using any kind of encoding like fixed width, delimited, XML, CSV and so forth.

C24IO also provides a transformation framework making it very easy to implement the [Message Translator][Message Translator] pattern using the C24IO tooling to design the transformation.

### Unmarshalling

The first step to using C24IO is usually to unmarshal some message from one of the Camel [Components][Components] like [File][File], [HTTP][HTTP] or [JMS][JMS] etc.

```
from("activemq:InputQueue").
  unmarshal(c24io(DocumentElement.class)).
  to("mqseries:OutputQueue");
```

The above unmarshals using the C24IO Data Format for the element *DocumentElement* which is generated by the C24IO tooling; DocumentElement is the root element of the message structure.

The above will use the default formatting for the data type. However with C24IO you can switch from the default format to other formats easily. So you could add a specific format if you wish...

```
  from("activemq:InputQueue").
    unmarshal(c24io(DocumentElement.class, C24IOContentType.Xml)).
    to("mqseries:OutputQueue");
```

If you use static imports this can be even more readable...

```
  unmarshal(c24io(DocumentElement.class, Xml)).
```

#### Unmarshalling SWIFT messages

If you are working with [SWIFT](http://en.wikipedia.org/wiki/Society_for_Worldwide_Interbank_Financial_Telecommunication) messages then there is a handy SwiftFormat helper class which avoids you having to know which Element class you want to use.

So you can unmarshal SWIFT messages using this code

```
from("activemq:InputQueue").
  unmarshal(new SwiftFormat()).
  to("mqseries:OutputQueue");
```

### Marshalling

Marshalling is the reverse of unmarshalling suprise suprise :).

Here's an example which unmarshals using one format (XML) and then marshals using a different format (in this case tagged value pairs).

```
from("activemq:XmlInput").
	unmarshal(c24io(DocumentElement.class, C24IOContentType.Xml)).
	marshal(c24io(C24IOContentType.TagValuePair)).
  	to("mqseries:TagOutput");
```

### Type conversions

An alternative to explicit unmarshalling in the DSL you can just use the common *convertBodyTo(Class)* method in the DSL to convert using the default content type to a particular ComplexDataObject from C24IO. This mechanism uses the inbuilt Camel [Type Converter][Type Converter] mechanism ot automatically marshal and unmarshal using the default content type for a model.

For example the following...

```
from("activemq:InputQueue").
  convertBodyTo(DocumentElement.class).
  to("mqseries:OutputQueue");
```

Is equivalent to this

```
from("activemq:InputQueue").
  unmarshal(c24io(DocumentElement.class)).
  to("mqseries:OutputQueue");
```


### Using Transformations

To use the [Message Translator][Message Translator] pattern with C24IO its a simple matter of using the C24IO tooling to create your transformation, then just using the generated transformation class in the [Bean Integration][Bean Integration] in Camel.

For example image you define a transformation in the C24IO IDE to translate SWIFT to FIX format. You will then have a generated SwiftToFix Java class. You can then use the transformation in your Camel DSL via Java or the [Xml Configuration][Xml Configuration] as follows

```
from("activemq:SwiftQueue").
  bean(SwiftToFix.class).
  to("mqseries:FixQueue");
```


### Configuring via Spring XML

The following example shows how to use C24IO using Spring XML; in this case it unmarshals the content of a JMS queue as XML using the C24IO data model; then marshals it using a tag/value pair.

    <camelContext id="camel" xmlns="http://activemq.apache.org/camel/schema/spring">
      <route>
        <from uri="activemq:MyInputQueue"/>
        <unmarshal ref="myDocFormat"/>
        <marshal ref="tagValueFormat"/>
        <to uri="mqseries:MyOutputQueue"/>
      </route>
    </camelContext>

    <bean id="myDocFormat" class="C24IODataFormat">
      <property name="elementTypeName" value="iso.std.iso.x20022.tech.xsd.pacs.x008.x001.x01.DocumentElement"/>
    </bean>

    <bean id="tagValueFormat" class="C24IODataFormat">
      <property name="contentType" value="TagValuePair"/>
    </bean>
    
In some cases your transformation can have multiple outputs with each possibly containing multiple instances. In other words a two dimensional container - one dimension for the different outputs and another for each of their instances. Here is and example of how to deal with that.
     
     <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
         <package>org.apache.camel.example.spring</package>
         <endpoint uri="file://src/data" id="sourceFile"/>
         <endpoint uri="file://src/target" id="targetDirectory"/>
 
         <route id="file_to_json">
             <from uri="sourceFile"/>
             <unmarshal ref="fromFile"/>
             <bean ref="theTransform"/>
             <split>
                <!-- splitting off each of the outputs -->
                 <simple>${body}</simple>
                 <split>
                     <!-- splitting off each of the instances for a given output -->
                     <simple>${body}</simple>
                     <bean ref="toJSONSink"/>
                     <to uri="targetDirectory"/>
                 </split>
             </split>
         </route>
 
     </camelContext>
 
     <!-- Input format setup -->
     <bean id="fromFile" class="biz.c24.io.camel.c24io.C24IOFormat">
         <property name="element" ref="elementToLoad"/>
     </bean>
     <bean id="elementToLoad" class="biz.c24.io.gettingstarted.transaction.TransactionsElement"/>
 
 
     <!-- Transform setup - NOTE the use of ...C24IOTransformAdvanced -->     
     <bean id="theTransform" class="biz.c24.io.camel.c24io.C24IOTransformAdvanced">
         <constructor-arg ref="myTransform"/>
     </bean>    
     <bean id="myTransform" class="biz.c24.io.gettingstarted.transaction.transactions.StatGenTransform"/>
 
     <!-- Output format setup -->
     <bean id="toJSONSink" class="biz.c24.io.camel.c24io.C24IOSink">
         <property name="sink" ref="jsonSink"/>
     </bean>
     
     <!-- Customising the JsonSink -->
     <bean id="jsonSink" class="biz.c24.io.api.presentation.JsonSinkv2">
         <property name="alwaysOutputMandatoryFields" value="true"/>
     </bean>

### Content Types and auto discovery

You may have spotted in the above that we use the [C24IOContentType](http://dev.c24.biz/camel_api/biz/c24/io/camel/c24io/C24IOContentType.html)
which is an _enum_ in Java and the [Xml Configuration][Xml Configuration] to describe the kind of XML format to use such as binary, XML, Text etc.

If no content type is specified we always use the default content type of the C24IO model in question. This is equivalent to the *Default* content type.

If you wish to be flexible in what you accept or emit, we also support the *Auto* content type which will look for the *Content-Type* header on the input message and use that to try determine which of the content types to use; if none can be found then *Default* is used.

e.g. you could support content posted with a MIME type of *application/xml* to indicate XML or *application/json* for JSON or *application/x-java-serialized-object* for serialization or *text/plain* for text etc.

### Using

To use this module you need to use the [FUSE Mediation Router](http://fusesource.com/products/enterprise-camel) distribution. Or you could just add the following to your pom.xml, substituting the version number for the latest & greatest release.

    <dependency>
      <groupId>biz.c24.io.camel</groupId>
      <artifactId>camel-c24io</artifactId>
      <version>\${camel-version}</version>
    </dependency>

And ensure you are pointing at the maven repo

    <repository>
      <id>c24io.public</id>
      <name>C24IO Public Repository</name>
      <url>http://repo.c24io.net:8081/nexus/content/groups/public</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <enabled>true</enabled>
      </releases>
    </repository>

[C24]: http:/c24.biz
[DataFormat]: http://camel.apache.org/data-format.html
[Message Translator]: http://camel.apache.org/message-translator.html
[Components]: http://camel.apache.org/components.html
[File]: http://camel.apache.org/file.html
[HTTP]: http://camel.apache.org/http.html
[JMS]: http://camel.apache.org/jms.html
[Bean Integration]: http://camel.apache.org/bean-integration.html
[Type Converter]: http://camel.apache.org/type-converter.html
[Xml Configuration]: http://camel.apache.org/xml-configuration.html